![WideImg](http://fictizia.com/img/github/Fictizia-plan-estudios-github.jpg)

# Curso de Vue.js + Vuex

## CLASE 4

**Styling**

* Configuraci칩n de preprocesadores
* Scoped vs general
* Ecosistema de dependencias

**Vue Router**

* vue-router
* Enrutado de aplicaci칩n b치sico
* Definici칩n de rutas
* Configuraci칩n router-link
* Gesti칩n de informaci칩n entre rutas
* Segmentos din치micos
* P치gina no encontrada
* Rutas anidadas
* Navegaci칩n program치tica
* Navigation Guards
* Transitions
* Lazy loading

### NORMAS E INFORMACI칍N DE INTER칄S

* Puntualidad
* L칤quidos y comida
* Descansos
* Cafeter칤a

## Styling 游땸

Vue tiene una integraci칩n muy buena con CSS nativo y nos permite escribir nuestros estilos seg칰n nuestras necesidades. De forma, que podemos escribir CSS de la forma en que m치s c칩modos nos sintamos.

Gracias a los `vue-loader`, podemos hacer uso de los preprocesadores y/o postprocesadores. Que se encargan de compilar nuestro CSS para que sea entendido y lo m치s compatible posible con los navegadores a los que queremos dar soporte.

De esta forma podemos escribir tambi칠n CSS con otras tecnolog칤as como: SASS, LESS y Stylus. Y con ayuda de tecnolog칤as como PostCSS no perdemos compatibilidad.

Para poder hacer uso de estas tecnolog칤as deberemos instalar los loader en cuesti칩n. Por ejemplo para instalar sass o postcss debemos hacer lo siguiente:

### Configuraci칩n de preprocesadores

```javascript
npm install -D sass-loader node-sass
npm install -D postcss-loader
```

Una vez instaladas las dependencias para hacer que nuestro CSS sea preprocesado debemos incluir el atributo `lang` en las etiquetas style de nuestros componentes, de la siguiente manera:

```html
<style lang="scss"></style>
<style lang="stylus"></style>
<style lang="less"></style>
```

As칤 podremos hacer uso de todo lo que un preprocesador nos aporta, v칠ase en el ejemplo a continuaci칩n: mixins, variables y herencia de clases.

```html
<style lang="scss">
.button {
  @include align-center-inside();
  font-family: $font-circular-book;

  &--small {
    width: 88px;
  }
}
</style>
```

### Scoped vs general

Vue nos ofrece de una forma muy sencilla poder limitar el CSS de nuestro a componente a dicho de componente, de forma que si utilizamos estilos gen칠ricos, 칠stos no afectar치n de forma gen칠rica a dichos estilos, s칩lo a aquello que hayamos definido en nuestro componente.

Esta forma se denomina `scoped`. Para poder hacer uso de este tipo de estilos bastar치 con agregar el atributo scoped a la etiqueta `<style>`:

```css
<style scoped>
.red {
 color: red;
}
</style>
```

Luego podremos hacer uso de esta clase de la misma manera que lo har칤amos sin el atributo scoped.

```html
<template>
  <p class="red">
    This should be red
  </p>
</template>
```

Por debajo Vue lo que est치 haciendo por nosotros es agregarle un **atributo 칰nico** a los elementos que tienen el estilo `scoped`, aqu칤 puedes ver un ejemplo:

```css
.list-container:hover 
.list-container[data-v-21e5b78]:hover
```

### CSS Modules

Los m칩dulos de CSS funcionan de forma similar a los estilos `scoped`, puesto que lo que hacen es limitar el CSS a nuestro componente. La 칰nica diferencia con el anterior es que en lugar de crear atributos 칰nicos a nuestros elementos, lo que hacen es crear **clases 칰nicas**, como puedes ver en el siguiente ejemplo:

```css
red
red_1VyoJ-uZ
```

Para poder hacer uso de los CSS modules, bastar치 con agregar el atributo `module` a nuestras etiquetas style.

```css
<style module>
.red {
 color: red;
}
</style>
```

Por otro lado para utilizar dicho m칩dulo de CSS tendremos que acceder al objeto `$style` que tendr치 como atributo todas nuestras clases.

```html
<template>
  <p :class="$style.red">
    This should be red
  </p>
</template>
```

### Clases y estilos

Como puedes observar Vue es muy flexible en cuanto a la forma de gestionar el CSS, nos permite trabajar los estilos de nuestros componentes de la forma en que m치s c칩modos nos sintamos.

Adem치s de todo esto nos permite poder aplicar clases y estilos a nuestros componentes en base a cierta l칩gica de una forma muy sencilla.

```html
<!-- one word class -->
<div :class="{ active: isActive }"></div>
<!-- two words class -->
<div :class="{ 'text-danger': hasError }"></div>
<!-- ternary class -->
<div :class="[ isActive ? activeClass : '' ]"></div>
```

```html
<!-- one word style -->
<div :style="{ color: activeColor }"></div>

<!-- two words style -->
<div :style="{ 'font-size': fontSize + 'px' }"></div>
```


#### PROYECTO
##### Styling

Have you seen this wizard?

- Recupera el proyecto de la b칰squeda y captura de magos
- Crea un formulario que te permita crear nuevos magos: nombre, precio e imagen.
- Modifica el CSS de cada campo en base a una validaci칩n m칤nima. Por ejemplo: que los tres campos tengan informaci칩n y que m칤nimo tengan 3 caracteres.

[Soluci칩n](https://codesandbox.io/s/have-you-seen-this-wizard-pepem)
[Demo](https://pepem.csb.app/)


## Vue Router

Hasta ahora hemos trabajado con **componentes base** y **componentes contenedores**.
Dejando de lado los **componentes vista**, que nos van a permitir crear componentes que se van a encargar de gestionar la aplicaci칩n dividida por rutas.

![Componentes vista](./01.png)

### vue-router

Es la librer칤a oficial de routing de Vue, por su integraci칩n completa con esta tecnolog칤a.
Los [contribuidores](https://github.com/vuejs/vue-router/graphs/contributors) principales de esta tecnolog칤a son: [Evan You](https://twitter.com/youyuxi) y [Eduardo San Mart칤n](https://twitter.com/posva).

Esta librer칤a esencialmente nos brinda la posibilidad de:

- Gestionar vistas
- Crear rutas anidadas
- Configuraci칩n de las rutas basadas en componentes vista
- Nos va a permitir pasar par치metros o query params entre rutas
- Crear un sistema de transiciones de rutas sencillo
- CSS en los links
- Modo HTML5 history
- Personalizar comportamiento del scroll

### Enrutado de aplicaci칩n b치sico

Para comenzar a desarrollar un enrutado b치sico de nuestra aplicaci칩n puede que nos encontremos en una de estas situaciones:

- **Proyecto nuevo**. Al crear el proyecto con el CLI de Vue podremos agregar **vue-router** como dependencia en la configuraci칩n manual del proyecto, siguiendo los siguientes pasos.

```javascript
? Check the features needed for your project: Babel, Router, Linter
? Use history mode for router? Yes
```

- **Proyecto iniciado**. Puede que tengamos un proyecto que inicialmente no estaba pensado para tener gesti칩n de rutas din치micas y ahora lo necesitemos. Los pasos a seguir son muy sencillos:

1. **Instalaci칩n** librer칤a en proyecto:

```
npm install vue-router --save
```

2. Crea una carpeta denomina `/router` dentro de la carpeta `/src` que incluya un fichero denominado: `index.js` donde vamos a incluir la **configuraci칩n** de nuestro router.

- En este fichero vamos importar vue y vue-router.
- Despu칠s le diremos a Vue que lo utilice como dependencia con Vue.use()
- Exportamos nuestro router que es una instancia de vue-router

```javascript
// router/index.js

import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)

export default new VueRouter({});
```

3. En nuestro fichero de javascript principal de la aplicaci칩n `main.js`. Deberemos importar el router y hacer uso del mismo en la instancia de Vue.

```javascript
// main.js
import Vue from 'vue'
import router from './router';
import App from './App.vue'

Vue.config.productionTip = false

new Vue({
  router,
  render: h => h(App),
}).$mount('#app')
```

4. Ya podemos empezar a configurar nuestro router en base a los componentes vista que hayamos creado.

```javascript
// router/index.js
import Vue from 'vue'
import VueRouter from 'vue-router'

// View Components imports
import Home from '@/views/Home.vue';
import About from '@/views/About.vue';

Vue.use(VueRouter)

// Configuration of router with this components
export default new VueRouter({
    routes: [
        { path: '/', component: Home },
        { path: '/about', component: About }
    ]
});
```

5. Para que el router funcione necesitaremos agregar el elemento `<router-view />` en nuestro componente principal: `App.vue`.

> <router-view> Es el encargado de cargar din치micamente el componente que le hayamos dicho en la configuraci칩n que debe cargar en base a la ruta en la que queremos acceder.

6. Para poder acceder a las distintas rutas podr칤amos crearnos un men칰 y hacer uso del componente `<router-link>` por cada una de ellas.

- Componente **TheHeader.vue** y agrega un t칤tulo y un men칰.
- Componente **TheFooter.vue** con informaci칩n est치tica.
- Incluye en **App.vue** ambos componentes y deja el componente `<router-view />` entre estos componentes
- Comprobar renderizado de componentes (*) Paint flashing 

```html
<router-link to="/">Home</router-link>
<router-link to="/about">About</router-link>
```

* [Ejemplo Router como librer칤a](https://jsfiddle.net/yyx990803/xgrjzsup/)
* [Ejemplo Router como framework](https://codesandbox.io/s/vue-with-simple-routing-uhlwf)

#### EJERCICIO
##### Enrutado de aplicaci칩n b치sico

**Wizards Characters**

- Crea una nueva aplicaci칩n Wizards Characters 
- Componente TheHeader.vue con un t칤tulo
- Componente TheFooter.vue con informaci칩n est치tica
- Crea dos componentes vista: Home y About
- Agrega un men칰 en el header que te permita navegar entre estas vistas

```html
<router-view />
<router-link to="/">Home</router-link>
```

[Soluci칩n](https://codesandbox.io/s/vue-with-simple-routing-uhlwf)

[Demo](https://uhlwf.csb.app/#/)

#### Definici칩n de rutas:

Cuando definimos nuestras rutas podemos crearlas con un **path, name y el componente** que queremos que se renderice en esa ruta.

```javascript
const router = new VueRouter({
  routes: [
    {
      path: '/wizard/:id',
      name: 'wizard',
      component: Wizard
    }
  ]
})
```

Tambi칠n podemos definir nuestras rutas de forma que podamos ver en una ruta diferentes **componentes**. Muy 칰til cuando estamos componentizando tambi칠n a nivel de layout.

```javascript
const router = new VueRouter({
  routes: [
    {
      path: '/',
      name: 'home',
      components: {
        default: Slider,
        main: Main,
        sidebar: Sidebar
      }
    }
  ]
})
```

```html
<router-view class="view slider"></router-view>
<router-view class="view main" name="main"></router-view>
<router-view class="view sidebar" name="sidebar"></router-view>
```

Desde la definici칩n de rutas, tambi칠n podemos hacer **redirecciones** de una forma muy sencilla:

```javascript
const router = new VueRouter({
  routes: [
    { path: '/my-whitelist', redirect: '/white-list' },
    { path: '/my-whitelist', redirect: { name: 'whitelist' }}
  ]
})
```

Adem치s, podemos agregar informaci칩n **meta** a las rutas, como informaci칩n complementaria de la ruta.

```javascript
const router = new VueRouter({
  routes: [
    { path: '/my-whitelist', meta: { requiresAuth: true } },
  ]
})
```

Para recuperar esta informaci칩n y poder redireccionar al login en caso de que el usuario no haya iniciado sesi칩n podremos gestionarlo de la siguiente forma:

```javascript
router.beforeEach((to, from, next) => {
  if (to.matched.some(record => record.meta.requiresAuth)) {
    if (!auth.loggedIn()) {
      next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
    } else {
      next()
    }
  } else {
    next()
  }
})
```

#### Configuraci칩n router-link

El componente `<router-link>` sirve de enlace para navegar entre rutas y nos permite configurarlo a trav칠s de las ya conocidas **props**.

```html
<router-link to="/" replace>Home</router-link>
```

Estas son las que nos permiten controlarlo:

* **to** - Ruta destino
* **replace** - Se aplica el m칠todo router.replace() en lugar de router.push()
* **append** - Anidaci칩n de rutas din치micas
* **tag** - Etiqueta a utilizar (*) Accesibilidad
* **active-class** - Por defecto: `router-link-active`
* **exact** - Ruta concreta
* **event** - Por defecto: click

### Gesti칩n de informaci칩n entre rutas

Con vue-router tenemos varias formas gestionar informaci칩n entre rutas:

#### Segmentos din치micos

- Crear un nuevo segmento en nuestra aplicaci칩n
- Este segmento adem치s va a ser din치mico
- Nos va a permitir reutilizar nuestros componentes

Veamos los segmentos din치micos con un ejemplo muy sencillo:

```javascript
// router/index.js
export default new VueRouter({
    routes: [
        { path: '/', component: Home },
        { path: '/about', component: About },
        { path: '/wizard/:id', component: Wizard }
    ]
});
```

Como puedes observar en el ejemplo, nos permite pasar una propiedad din치mica a trav칠s de la informaci칩n de la ruta. De esta forma estamos reutilizando el componente vista **Wizard** para todas las subrutas de wizard.


En el componente podemos recuperar el valor que nos viene dado en la ruta como par치metro, dentro del objeto `$route`.

```html
<!-- Wizard.vue -->
<p>Wizard {{ $route.params.id }}</p>
```

A la hora de crear el enlace que me va a llevar al detalle de este mago, la ruta se podr칤a crear din치micamente con ayuda de `router-link`.

```html
<!-- TheHeader.vue -->
<router-link class="the-header__link" to="/wizard/5">Wizard</router-link>
<router-link class="the-header__link" :to="`/wizard/${wizard.id}`">Wizard</router-link>
```

[Ejemplo](https://codesandbox.io/s/vue-with-dynamic-segment-0jc3e)

Otra forma de recibir la informaci칩n entre rutas, puede ser como una **prop**, de forma que el componente vista va a recibir esa informaci칩n como una prop m치s. Y no necesitamos acceder a la informaci칩n de la ruta con `$route`.

Veamos un ejemplo:

```javascript
const router = new VueRouter({
  routes: [
    {
      path: '/wizard/:id',
      component: Wizard,
      props: true
    },
  ] 
})
```

```html
<!-- Wizard.vue -->
<!-- Before -->
<p>Wizard {{ $route.params.id }}</p>
<!-- After -->
<p>Wizard {{ id }}</p>
```

#### EJERCICIO
##### Segmentos din치micos

Wizard Characters

- Recupera la aplicaci칩n Wizards Characters 
- Utiliza el endpoint /characters de potterapi.com o http://hp-api.herokuapp.com/api/characters
- Recupera en la home el listado de todos los magos con un componente que reutilices WizardCard
- El componente debe tener un enlace a una p치gina detalle de ese mago con una propiedad din치mica que te permita recuperar el mago al entrar al detalle

[Demo](https://6mbfr.csb.app/)

```javascript
fetch('https://www.potterapi.com/v1/characters?key=APY_KEY')
.then((response) => response.json())
.then((characters) => console.log(characters));
```

Si lo prefieres puedes utilizar este [mock](https://codesandbox.io/s/wizards-whr6y)


#### QueryParams

Previamente hemos visto c칩mo acceder a los par치metros que vienen dados en la ruta, pero tambi칠n podemos acceder a los queryParams que normalmente vienen relacionados con una b칰squeda en la aplicaci칩n por parte del usuario y se ven en la ruta de la siguiente forma: `/?name=potter`.

![QueryParams](./02.png)

Para poder recuperarlos en un componente vista bastar치 con acceder a la informaci칩n de la ruta actual de la siguiente forma:

```javascript
$route.query.name
```

En caso de querer modificarlos podremos utilizar los m칠todos propios del router para modificar los queryParams de esta ruta:

```javascript
$router.push({ query: { name: 'potter' }})
```

A trav칠s de la configuraci칩n de rutas, tambi칠n podemos interceptar los queryParams para modificarlos al modelo de datos que espera la vista y que 칠sta los reciba como props. 

Muy 칰til para desacoplar la l칩gica del proyecto del SEO definido para el proyecto.

Veamos un ejemplo:

```javascript
const router = new VueRouter({
  routes: [
    { path: '/', component: Home, props: (route) => ({ search: route.query.s }) }
  ]
})
```

Si el usuario aplica una b칰squeda en la URL lo veremos as칤: `/?s=potter`
Y nuestro componente Home recibir치 como prop: `{search: 'potter'}`

#### EJERCICIO
##### QueryParams

**Wizards Characters**

- Recupera la aplicaci칩n Wizards Characters 
- Crea un campo de texto que te permita filtrar los personajes por nombre cuando el usuario haga clic en un bot칩n auxiliar y/o cuando pulse la tecla enter
- Cuando la b칰squeda se ejecute guarda en la URL la b칰squeda como queryParams
- BONUS: 
  - Si recargas la p치gina y hay queryParams tendr치s que guardar la b칰squeda
  - Gestionar resultados filtrados, de forma que si no hay resultados aparezca un mensaje al usuario

#### P치gina no encontrada

Si queremos gestionar que alguien est치 intentando entrar a una ruta no controlada podemos poner en la configuraci칩n de nuestro router el `path: '*'` y renderizar el componente de P치gina no encontrada.

```javascript
// router/index.js
export default new VueRouter({
    routes: [
        // The last one
        { path: '*', component: PageNotFound }
    ]
});
```

[Ejemplo](https://codesandbox.io/s/vue-with-page-not-found-8bwrs)


#### EJERCICIO
##### P치gina no encontrada

Wizards Characters

- Recupera la aplicaci칩n Wizards Characters 
- Agrega la configuraci칩n y el componente PageNotFound en tu aplicaci칩n para controlar los accesos a una ruta no controlada

### Rutas anidadas

En varias ocasiones vamos a precisar de hacer uso de las rutas anidadas, que no dejan de ser subrutas.

Por ejemplo: queremos acceder a la secci칩n de `/settings` de nuestra aplicaci칩n y esta secci칩n tiene como subrutas: `/settings/profile` `/settings/notifications`.

Para poder construir este tipo de rutas en nuestra aplicaci칩n debemos configurar nuestro routing de la siguiente manera:

```javascript
export default new VueRouter({
    routes: [
        { 
            path: '/settings',
            component: Settings,
            children: [
                {
                    path: 'profile',
                    component: SettingsProfile
                },
                {
                    path: 'notifications',
                    component: SettingsNotifications
                }
            ]
        },
        { path: '*', component: PageNotFound }
    ]
});
```

Hacemos uso del nodo `children` para poder crear las subrutas. Pero para hacerlo funcionar precisamos que en nuestro componente `Settings.vue` tengamos un `<router-view/>` definido que es donde nuestros componentes se van a renderizar.

```html
<template>
    <div>
        <h2>Settings</h2>
        <router-link class="app__link" to="/settings/profile">Profile</router-link>
        <router-link class="app__link" to="/settings/notifications">Notifications</router-link>
        <router-view />
    </div>
</template>
```

As칤 podremos navegar entre nuestros componentes y si inspeccionamos con las herramientas de renderizado nuestra p치gina veremos todo su potencial en marcha.

[Ejemplo](https://codesandbox.io/s/vue-with-nested-routes-nfdkk)

#### EJERCICIO
##### Rutas anidadas

Wizards Characters

- Recupera la aplicaci칩n Wizards Characters 
- Crea una secci칩n de tu aplicaci칩n que te permita tener rutas anidadas
- Por ejemplo: universo harry potter, libros, peliculas...

### Navegaci칩n program치tica

Hasta ahora hemos visto la forma m치s declarativa que nos permite Vue de gestionar las rutas en nuestras aplicaciones. Que esencialmente se resume en configurar el router en nuestro fichero de configuraci칩n `router/index.js`, crear los componentes vista necesarios para esas rutas y permitir el acceso a esas rutas o subrutas gracias a `<router-view>` y `<router-link>`.

Pero dentro de nuestros componentes tambi칠n podemos gestionar las rutas de forma program치tica y es realmente sencillo si se entienden los conceptos clave.

`this.$router` Equivale a la instancia de nuestro router. [Documentaci칩n](https://router.vuejs.org/api/#router-instance-methods)

`this.$route` Equivale a la ruta en la que estamos. [Documentaci칩n](https://router.vuejs.org/api/#the-route-object)

#### router.push()

Con `router.push()` estamos navegando de forma program치tica a otra ruta a partir de cierta l칩gica en nuestra aplicaci칩n.

Imaginemos un sencillo sistema de autorizaci칩n. Si el usuario no est치 autenticado y est치 intentando acceder a una ruta privada, lo que podemos hacer previamente es comprobar su sesi칩n y si no est치 activa le redirigiremos a la p치gina de login.

```javascript
router.push(location, onComplete?, onAbort?)
```

```javascript
// literal string path
router.push('/')

// object
router.push({ path: '/' })

// path with paramas
router.push({ path: `/wizard/${wizardId}` })

// named route
router.push({ name: 'wizard', params: { wizardId } })

// with query, resulting in /register?search=potter
router.push({ path: '/', query: { search: 'potter' } })
```

El equivalente de forma declarativa a este m칠todo ser칤a la utilizaci칩n de la etiqueta `<router-link>` con el atributo `to` definido.


| Declarativa                         | Program치tica                        |
| ----------------------------------- | ----------------------------------- |
| `<router-link :to="...">`           | `router.push(...)`                  |


춰IMPORTANTE! Con este m칠todo estamos manteniendo el hist칩rico de nuestro navegador y estamos agregando esta nueva navegaci칩n. De forma que si el usuario intenta volver atr치s, a la ruta anterior, vamos a tener acceso a esta navegaci칩n en el hist칩rico de navegaciones.

#### router.replace()

Con `router.replace()` igual que sucede con el m칠todo `router.push()`, estamos navegando de forma program치tica a otra ruta en base a la l칩gica de nuestra aplicaci칩n.

La diferencia entre `push` y `replace` es que el primero se guarda en el hist칩rico de navegaciones. El segundo solo reemplaza la ruta en la que estamos y NO la agrega al hist칩rico.

```javascript
router.replace(location, onComplete?, onAbort?)
```

```javascript
// literal string path
router.replace('/')

// object
router.replace({ path: '/' })

// path with paramas
router.replace({ path: `/wizard/${wizardId}` })

// named route
router.replace({ name: 'wizard', params: { wizardId } })

// with query, resulting in /register?search=potter
router.replace({ path: '/', query: { search: 'potter' } })
```

| Declarativa                         | Program치tica                        |
| ----------------------------------- | ----------------------------------- |
| `<router-link :to="..." replace>`   | `router.replace(...)`               |


#### router.go(n)

Con este m칠todo podemos navegar hacia delante o detr치s entre el hist칩rico del navegador tantas veces como le hayamos indicado por par치metro.

Funciona de igual forma que: `window.history.go(n)`

```javascript
router.go(1)
router.go(-1)
```

### Navigation Guards

Una **navigation guard** nos va a permitir proteger todas las navegaciones en nuestra aplicaci칩n.
Nos va a permitir redireccionar o cancelar la navegaci칩n.
Se pueden crear de tres formas: globalmente, por ruta o por componente.
Funciona de forma muy similar a los hooks de los componentes.

#### Global: router.beforeEach()

Esta guarda se va a ejecutar cada vez que se lance una nueva navegaci칩n.
De forma que nos permite interceptar todas las navegaciones antes de que se completen.

Podemos ver un ejemplo muy recurrente, que es cuando tenemos un sistema de rutas p칰blicas y privadas. Pues podemos hacer esta comprobaci칩n a nivel global interceptando todos los accesos.

```javascript
router.beforeEach((to, from, next) => {
  if (!isAuthenticated) next('/login')
  else next()
})
```

`next()` : Se mueve al siguiente hook y confirma la navegaci칩n.
`next(false)` : Nos permite abortar la navegaci칩n.
`next('/')` o `next({ path: '/' })` : Aborta la navegaci칩n previa y redirige a otra navegaci칩n.
`next(error)`: Aborta la navegaci칩n y genera un error.

(*) Tras ejecutar el hook siempre hay que utilizar next(), si no, la navegaci칩n quedar치 bloqueada.

#### Global: router.beforeResolve()

Se ejecuta justo antes de se confirme la navegaci칩n.
Se ejecuta despu칠s de que se resuelvan todas las guardas en los componentes.

```javascript
router.beforeResolve((to, from, next) => {
  // ...
})
```

#### Global: router.afterEach()

Esta guarda se ejecuta cuando la navegaci칩n a una ruta se ha completado.
De hecho, no afecta a la navegaci칩n pero nos permite ejecutar l칩gica a posteriori de que la ruta haya sido cargada.

```javascript
router.afterEach((to, from) => {
  // ...
})
```

#### Ruta: beforeEnter()

Este tipo de guarda se define en la configuraci칩n de la ruta en la que queremos hacer comprobaciones previas a la navegaci칩n.

Es similar a `beforeEach()` solo que 칠ste se ejecuta para todas las rutas y `beforeEnter()` solo en las rutas que lo hayamos configurado.

```javascript
const router = new VueRouter({
  routes: [
    {
      path: '/',
      component: Home,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```

#### Componentes: beforeRouteEnter / beforeRouteUpdate / beforeRouteLeave

En los componentes de tipo vista podemos hacer uso de tres guardas espec칤ficas que nos van a permitir controlar la navegaci칩n a dicha ruta.

**beforeRouteEnter()**

- Se ejecuta antes de que el componente se renderize
- No tenemos acceso a `this` como componente

```javascript
beforeRouteEnter (to, from, next) {
    //...
},
```

**beforeRouteUpdate()**

- Se ejecuta cuando la ruta es modificada y se reutiliza el componente.
- Por ejemplo, por modificaci칩n de par치metros en la ruta
- Tenemos acceso a `this`

```javascript
beforeRouteUpdate (to, from, next) {
    // ...
},
```

**beforeRouteLeave()**

- Se ejecuta justo antes de que abandonemos la ruta
- Nos permite acceder a `this`
- Podemos cancelar la navegaci칩n `next(false)`
- Muy 칰til si el usuario se marcha sin confirmar los cambios.

```javascript
beforeRouteLeave (to, from, next) {
    // ...
}
```

#### EJERCICIO
##### Navigation guards

**Wizards Characters** 

- Recupera la aplicaci칩n Wizards Characters 
- Crea una secci칩n de tu aplicaci칩n que te permita tener controlado el login de tus usuarios
- Para ello puedes controlar con router.beforeEach() a nivel global el acceso a tus rutas
- Crea una p치gina de login y guarda la sesi칩n del usuario cada vez que complete el formulario de login
- Redirige al usuario cuando complete su login a la home

El flujo de las navegaciones:

- Se lanza ejecuci칩n de navegaci칩n.
- `beforeRouteLeave()` en componentes
- `beforeEach()` a nivel global
- `beforeRouteUpdate()` en componentes
- `beforeEnter()` en la configuraci칩n de rutas
- Componentes as칤ncronos
- `beforeRouteEnter()` en componentes
- `beforeResolve()` a nivel global
- Se confirma la navegaci칩n
- `afterEach()` a nivel global
- Se actualiza el DOM
- `beforeRouteEnter()` callback

### Transitions

El elemento `<transition>` permite aplicar efectos de transiciones.

Cuando un elemento es: insertado, actualizado o eliminado del DOM.

Muy 칰til cuando estamos utilizando:

- Renderizado condicional (v-if / v-show)
- Componentes din치micos
- Cuando solo hay un nodo root en el componente

- Podemos aplicarlo a nivel general para todos los `<router-view>`

```html
<transition>
    <router-view></router-view>
</transition>
```

- Podemos aplicarlo dentro del componente para aplicarle un estilo espec칤fico.

```html
<transition name="fade">
    <div>...</div>
</transition>
```

```html
<transition name="slide">
    <div>...</div>
</transition>
```

```css
// fade
.fade-enter-active,
.fade-leave-active {
  transition: opacity .5s;
}
.fade-enter, .fade-leave-to {
  opacity: 0;
}
```
```css
// slide
.slide-fade-enter-active {
  transition: all .3s ease;
}
.slide-fade-leave-active {
  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
}
.slide-fade-enter,
.slide-fade-leave-to {
  transform: translateX(10px);
  opacity: 0;
}
```

#### Estados de transiciones

![Estados de transiciones](./00.png)

* **v-enter**: Comienza la transici칩n de entrada. Justo antes de que el elemento en cuesti칩n sea insertado o eliminado.

* **v-enter-to**: Comienza cuando finaliza el estado de entrada. Se agrega un frame despu칠s de que el elemento haya sido insertado o eliminado.

* **v-enter-active**: Se da mientras el estado de entrada est치 activo. Se agrega antes de que el elemento sea insertado o eliminado y se elimina cuando la transici칩n ha finalizado. Se suele utilizar para definir la duraci칩n y efecto de la transici칩n.

* **v-leave**: Comienza cuando el estado de salida se lanza. Se agrega inmediatamente cuando una transici칩n de salida es lanzada.

* **v-leave-to**: Comienza cuando el estado de salida finaliza. Se agrega un frame despu칠s de que la transici칩n haya finalizado.

* **v-leave-active**: Se da mientras el estado de salida est치 activo. Se agrega antes de que la transici칩n de salida sea lanzada y se elimina cuando la animaci칩n ha finalizado. Se suele utilizar para definir la duraci칩n y efecto de la transici칩n.

Renderizado inicial con animaci칩n:

```html
<transition appear>
  <!-- ... -->
</transition>
```

[Ejemplo](https://github.com/vuejs/vue-router/tree/dev/examples/transitions)

### Lazy loading

- Nos permite cargar un componente s칩lo cuando la ruta es visitada
- Nos permite hacer code-spliting
- Un fichero por cada ruta Ej: wizard.[hash].js

```javascript
  {
    path: '/wizard',
    name: 'wizard',
    component: () => import('../views/Wizard.vue')
  }
```

[Proyecto Soluci칩n](https://github.com/crisgrim/wizard-characters)

### RECURSOS

- [Gu칤a oficial vue-router](https://router.vuejs.org/guide/)
- [API oficial vue-router](https://router.vuejs.org/api/)
- [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)
- [History Mode - Configuraci칩n servidor](https://router.vuejs.org/guide/essentials/history-mode.html#example-server-configurations)
- [Ejemplos con vue-router](https://github.com/vuejs/vue-router/tree/dev/examples)
- [Lazy loading con vue](https://vueschool.io/articles/vuejs-tutorials/lazy-loading-and-code-splitting-in-vue-js/)
- [Transiciones](https://vuejs.org/v2/guide/transitions.html)